# Day 06 - Бассейн SQL

## _Улучшим клиентский опыт_

Загрузите [скрипт](../materials/model.sql) с моделью базы данных здесь и примените его к своей базе данных (вы можете использовать командную строку с psql или просто запустить его через любую IDE, например DataGrip от JetBrains или pgAdmin от сообщества PostgreSQL).

![schema](../materials/schema.png)

1. **pizzeria** (Таблица-словарь с доступными пиццериями)
- id - первичный ключ (primary key)
- name - название пиццерии
- rating - средний рейтинг пиццерии (от 0 до 5 баллов)
2. **person** (Таблица-словарь с людьми, которые любят пиццу)
- id - первичный ключ
- name - имя человека
- age - возраст человека
- gender - пол человека
- address - адрес человека
3. **menu** (Таблица-словарь с доступным меню и ценой на конкретную пиццу)
- id - первичный ключ
- pizzeria_id - внешний ключ к пиццерии (foreign key)
- pizza_name - название пиццы в пиццерии
- price - цена конкретной пиццы
4. **person_visits** (Операционная таблица с информацией о посещениях пиццерии)
- id - первичный ключ
- person_id - внешний ключ к человеку
- pizzeria_id - внешний ключ к пиццерии
- visit_date - дата (например 2022-01-01) посещения человека
5. **person_order** (операционная таблица с информацией о заказах людей)
- id - первичный ключ
- person_id - внешний ключ к человеку
- menu_id - внешний ключ к меню
- order_date - дата (например 2022-01-01) заказа человека

Посещение лиц и заказ лиц являются разными сущностями и не содержат никакой корреляции между данными. Например, клиент может находиться в одном ресторане (просто просматривая меню) и в это время сделать заказ в другом по телефону или через мобильное приложение. Или другой случай, просто быть дома и снова сделать звонок с заказом без всяких визитов.

## Chapter IV
## Exercise 00 - Упражнение 00 - Скидки, скидки, все любят скидки

Давайте расширим нашу модель данных, включив в нее новую бизнес-функцию. Каждый человек хочет видеть персональную скидку и каждый бизнес хочет быть ближе к клиентам.

Пожалуйста, подумайте о персональных скидках для людей с одной стороны и ресторанов-пиццерий с другой. Необходимо создать новую реляционную таблицу (укажите имя `person_discounts`) со следующими правилами.
- установите атрибут id как первичный ключ (пожалуйста, посмотрите на столбец id в существующих таблицах и выберите тот же тип данных)
- установить внешние ключи атрибутов person_id и pizzeria_id для соответствующих таблиц (типы данных должны быть такими же, как и для столбцов id в соответствующих родительских таблицах)
- пожалуйста, установите явные имена для ограничений внешних ключей по шаблону fk_{table_name}_{column_name}, например `fk_person_discounts_person_id`
- добавьте атрибут скидки для хранения значения скидки в процентах. Помните, что значение скидки может быть числом с плавающей запятой (просто используйте `numeric` тип данных). Поэтому, пожалуйста, выберите соответствующий тип данных, чтобы покрыть эту возможность.

## Упражнение 01. Установим персональные скидки

Собственно, мы создали структуру для хранения наших скидок и готовы идти дальше и наполнять нашу `person_discounts` таблицу новыми записями.

Итак, есть таблица `person_order`, в которой хранится история заказов человека. Пожалуйста, напишите оператор DML ( `INSERT INTO ... SELECT ...`), который вставляет новые записи в `person_discounts` таблицу на основе следующих правил.
- взять агрегированное состояние по столбцам person_id и pizzeria_id
- рассчитать величину персональной скидки по следующему псевдокоду:

    `if “amount of orders” = 1 then
        “discount” = 10.5
    else if “amount of orders” = 2 then
        “discount” = 22
    else
        “discount” = 30`

- чтобы сгенерировать первичный ключ для таблицы person_discounts, используйте приведенную ниже конструкцию SQL (эта конструкция взята из области SQL WINDOW FUNCTION).

    `... ROW_NUMBER( ) OVER ( ) AS id ...`

## Упражнение 02 - Пересчитаем историю заказов

Пожалуйста, напишите оператор SQL, который возвращает заказы с фактической ценой и ценой с примененной скидкой для каждого человека в соответствующем ресторане-пиццерии и сортирует по имени человека и названию пиццы. Пожалуйста, взгляните на образец данных ниже.

| name | pizza_name | price | discount_price | pizzeria_name |
| ------ | ------ | ------ | ------ | ------ |
| Andrey | cheese pizza | 800 | 624 | Dominos |
| Andrey | mushroom pizza | 1100 | 858 | Dominos |
| ... | ... | ... | ... | ... |

## Упражнение 03. Возможны улучшения

На самом деле нам нужно улучшить согласованность данных с одной стороны и настроить производительность с другой. Создайте многостолбцовый уникальный индекс (с именем `idx_person_discounts_unique`), который предотвращает дублирование парных значений идентификаторов человека и пиццерии.

После создания нового индекса предоставьте любую простую инструкцию SQL, подтверждающую использование индекса (с помощью `EXPLAIN ANALYZE`). Пример «доказательства» ниже

    ...
    Index Scan using idx_person_discounts_unique on person_discounts
    ...

## Упражнение 04. Нам нужно больше согласованности данных

Добавьте следующие правила ограничения для существующих столбцов `person_discounts` таблицы.
- Столбец person_id не должен быть NULL (используйте имя ограничения `ch_nn_person_id`)
- Столбец pizzeria_id не должен быть NULL (используйте имя ограничения `ch_nn_pizzeria_id`)
- Столбец скидки не должен быть NULL (используйте имя ограничения `ch_nn_discount`)
- Столбец скидки должен быть 0 процентов по умолчанию
- Столбец скидки должен находиться в диапазоне значений от 0 до 100 (используйте имя ограничения `ch_range_discount`)

## Упражнение 05. Правила управления данными

Чтобы соответствовать политикам управления данными, необходимо добавить комментарии к таблице и столбцам таблицы. Применим эту политику к `person_discounts` таблице. Пожалуйста, добавьте комментарии на английском или русском языке (на ваше усмотрение), объясняющие, какова бизнес-цель таблицы и всех включенных в нее атрибутов.

## Упражнение 06. Автоматизируем генерацию первичного ключа

Давайте создадим последовательность базы данных с именем `seq_person_discounts` (начиная с 1 значения) и установим значение по умолчанию для атрибута id таблицы, чтобы каждый раз автоматически `person_discounts` принимать значение `seq_person_discounts`. Имейте в виду, что ваш следующий порядковый номер равен 1, в этом случае установите фактическое значение для последовательности базы данных на основе формулы «количество строк в таблице person_discounts» + 1. В противном случае вы получите ошибки об ограничении нарушения первичного ключа.